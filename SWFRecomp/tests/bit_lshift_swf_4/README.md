# BIT_LSHIFT (0x63) - ActionScript Bitwise Left Shift Test

## Opcode Information

**Opcode Name**: BIT_LSHIFT (ActionBitLShift)
**Hex Value**: 0x63
**Category**: Bitwise Logic
**Complexity**: SIMPLE

## Description

This test validates the implementation of the ActionScript 2 bitwise left shift operator (`<<`). The opcode pops two values from the stack (shift count, then value), converts them to 32-bit signed integers, masks the shift count to 5 bits (0-31 range), performs the left shift operation, and pushes the result back onto the stack.

## Operation Details

1. **Pop shift_count** from stack (first pop)
2. **Pop value** from stack (second pop)
3. **Convert both to 32-bit signed integers** (truncate, don't round)
4. **Mask shift_count** to 5 bits: `shift_count & 0x1F`
5. **Perform left shift**: `result = value << shift_count`
6. **Push result** as signed 32-bit integer (stored as float)

## Test Cases

### Test 1: Basic left shift
```actionscript
trace(1 << 3);  // 0001 << 3 = 1000 = 8
```
**Expected**: `8`

### Test 2: Multiply by power of 2
```actionscript
trace(5 << 2);  // 5 * 4 = 20
```
**Expected**: `20`
**Note**: Left shift by n is equivalent to multiplying by 2^n

### Test 3: Shift count wrapping (5-bit masking)
```actionscript
trace(1 << 33);  // 33 & 0x1F = 1, so 1 << 1 = 2
```
**Expected**: `2`
**Note**: Only the least significant 5 bits of shift_count are used

### Test 4: Zero shift
```actionscript
trace(42 << 0);  // No shift
```
**Expected**: `42`

### Test 5: Maximum shift (sign bit)
```actionscript
trace(1 << 31);  // Shift into sign bit
```
**Expected**: `-2147483648`
**Note**: Shifting into bit 31 sets the sign bit, making the result negative

## Implementation Notes

### Key Implementation Details

1. **Pop Order**: Critical! The shift_count is popped first, then the value
   ```c
   popVar(stack, sp, &shift_count_var);  // First pop
   popVar(stack, sp, &value_var);        // Second pop
   ```

2. **Shift Count Masking**: Only 5 bits are used (0-31 range)
   ```c
   shift_count = shift_count & 0x1F;
   ```

3. **32-bit Signed Integer**: Both operands and result are signed
   ```c
   int32_t shift_count = (int32_t)VAL(float, &shift_count_var.data.numeric_value);
   int32_t value = (int32_t)VAL(float, &value_var.data.numeric_value);
   int32_t result = value << shift_count;
   ```

4. **Result Storage**: Result is converted back to float for stack storage
   ```c
   float result_f = (float)result;
   PUSH(ACTION_STACK_VALUE_F32, VAL(u32, &result_f));
   ```

### Files Modified

1. **SWFRecomp/include/action/action.hpp**: Added `SWF_ACTION_BIT_LSHIFT = 0x63` enum
2. **SWFRecomp/src/action/action.cpp**: Added translation case for BIT_LSHIFT
3. **SWFModernRuntime/include/actionmodern/action.h**: Added `actionBitLShift` declaration
4. **SWFModernRuntime/src/actionmodern/action.c**: Implemented `actionBitLShift` function

## Building and Running

```bash
# Build the test
cd SWFRecomp
./scripts/build_test.sh bit_lshift_swf_4 native

# Run the test
./tests/bit_lshift_swf_4/build/native/bit_lshift_swf_4
```

## Expected Output

```
SWF Runtime Loaded (Native Build)

=== SWF Execution Started (NO_GRAPHICS mode) ===

[Frame 0]
8
20
2
42
-2147483648
[Tag] ShowFrame()

=== SWF Execution Completed ===
```

## Test SWF Generation

The test SWF is generated by the Python script `create_test_swf.py`. The script creates a minimal SWF4 file with five BIT_LSHIFT operations followed by TRACE actions.

### Stack Order for Binary Operations

For the expression `value << shift_count`:
- **Push value first** (becomes second operand after two pops)
- **Push shift_count second** (becomes first operand after first pop)
- **Execute BIT_LSHIFT opcode (0x63)**

This is the reverse of the evaluation order because SWF uses a stack-based execution model.

## Verification

✅ All test cases pass
✅ Shift count masking works correctly (Test 3)
✅ Sign bit handling works correctly (Test 5)
✅ Zero shift works correctly (Test 4)
✅ Basic operations work correctly (Tests 1 & 2)

## Implementation Date

**Completed**: 2025-11-05
**Implementation Time**: ~30 minutes
**Status**: ✅ All tests passing
